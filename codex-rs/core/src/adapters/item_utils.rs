//! Shared utilities for working with ResponseItems across adapters
//!
//! This module provides common functions for:
//! - Identifying LLM-generated vs user-input items
//! - Getting human-readable type names for debugging
//! - Supporting incremental input filtering logic

use codex_protocol::models::ResponseItem;

/// Determine if a ResponseItem was generated by the LLM.
pub fn is_llm_generated(item: &ResponseItem) -> bool {
    match item {
        // LLM outputs (server has via previous_response_id)
        ResponseItem::Message { role, .. } if role == "assistant" => true,
        ResponseItem::Reasoning { .. } => true,
        ResponseItem::FunctionCall { .. } => true,
        ResponseItem::CustomToolCall { .. } => true,
        ResponseItem::LocalShellCall { .. } => true,
        ResponseItem::WebSearchCall { .. } => true,

        // User inputs (server needs in request)
        ResponseItem::FunctionCallOutput { .. } => false,
        ResponseItem::CustomToolCallOutput { .. } => false,
        ResponseItem::Message { role, .. } if role == "user" => false,
        ResponseItem::GhostSnapshot { .. } => false,
        ResponseItem::CompactionSummary { .. } => false,
        ResponseItem::Other => false,

        // Edge case: message with unknown role (defensive)
        ResponseItem::Message { .. } => false,
    }
}

/// Truncate content for summary display.
///
/// - Replaces newlines with spaces
/// - Truncates to max_len characters with "..." suffix
/// - Handles Unicode safely
fn truncate_content(s: &str, max_len: usize) -> String {
    let s = s.replace('\n', " ");
    if s.chars().count() <= max_len {
        s
    } else {
        format!("{}...", s.chars().take(max_len).collect::<String>())
    }
}

/// Get human-readable type name with summary for a ResponseItem.
///
/// Enhanced output includes:
/// - FunctionCall: includes tool name, e.g., `FunctionCall(read_file)`
/// - CustomToolCall: includes tool name, e.g., `CustomToolCall(mcp_search)`
/// - FunctionCallOutput: includes status and content summary, e.g., `FunctionCallOutput(âœ“, "content...")`
/// - CustomToolCallOutput: includes content summary, e.g., `CustomToolCallOutput("result...")`
pub fn get_item_type_name(item: &ResponseItem) -> String {
    match item {
        ResponseItem::Message { role, .. } if role == "assistant" => {
            "Message(assistant)".to_string()
        }
        ResponseItem::Message { role, .. } if role == "user" => "Message(user)".to_string(),
        ResponseItem::Message { .. } => "Message(other)".to_string(),
        ResponseItem::Reasoning { .. } => "Reasoning".to_string(),

        // FunctionCall: include tool name
        ResponseItem::FunctionCall { name, .. } => format!("FunctionCall({name})"),

        // FunctionCallOutput: include success status + content summary
        ResponseItem::FunctionCallOutput { output, .. } => {
            let status = match output.success {
                Some(true) => "Y",
                Some(false) => "N",
                None => "?",
            };
            let content = truncate_content(&output.content, 20);
            format!("FunctionCallOutput({status}, \"{content}\")")
        }

        // CustomToolCall: include tool name
        ResponseItem::CustomToolCall { name, .. } => format!("CustomToolCall({name})"),

        // CustomToolCallOutput: include output summary
        ResponseItem::CustomToolCallOutput { output, .. } => {
            let content = truncate_content(output, 20);
            format!("CustomToolCallOutput(\"{content}\")")
        }

        ResponseItem::LocalShellCall { .. } => "LocalShellCall".to_string(),
        ResponseItem::WebSearchCall { .. } => "WebSearchCall".to_string(),
        ResponseItem::GhostSnapshot { .. } => "GhostSnapshot".to_string(),
        ResponseItem::CompactionSummary { .. } => "CompactionSummary".to_string(),
        ResponseItem::Other => "Other".to_string(),
    }
}

/// Get type name breakdown for a slice of ResponseItems.
pub fn get_item_type_names(items: &[ResponseItem]) -> Vec<String> {
    items.iter().map(get_item_type_name).collect()
}

/// Filter input to get items after last LLM-generated item (zero-copy).
///
/// Used for incremental mode when `previous_response_id` is present.
/// The server already has history up to the last LLM response, so we only
/// need to send user inputs that occurred after that point.
///
/// # Returns
///
/// - `None` - No LLM items found (first turn, caller should use full input)
/// - `Some(&[])` - LLM item is last (error state, caller should return error)
/// - `Some(&[...])` - Items after last LLM item (normal case)
///
/// # Example
///
/// ```
/// use codex_core::adapters::filter_incremental_input;
///
/// match filter_incremental_input(&prompt.input) {
///     None => /* first turn, use full input */,
///     Some(slice) if slice.is_empty() => /* error: no user input after LLM */,
///     Some(slice) => /* use filtered slice */,
/// }
/// ```
pub fn filter_incremental_input<'a>(full_input: &'a [ResponseItem]) -> Option<&'a [ResponseItem]> {
    let last_llm_idx = full_input.iter().rposition(is_llm_generated)?;
    Some(&full_input[last_llm_idx + 1..])
}

#[cfg(test)]
mod tests {
    use super::*;
    use codex_protocol::models::ContentItem;
    use codex_protocol::models::FunctionCallOutputPayload;

    #[test]
    fn test_is_llm_generated_identifies_assistant_messages() {
        let assistant_msg = ResponseItem::Message {
            id: Some("msg_123".to_string()),
            role: "assistant".to_string(),
            content: vec![ContentItem::OutputText {
                text: "response".to_string(),
            }],
        };
        assert!(is_llm_generated(&assistant_msg));

        let user_msg = ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![ContentItem::InputText {
                text: "query".to_string(),
            }],
        };
        assert!(!is_llm_generated(&user_msg));
    }

    #[test]
    fn test_is_llm_generated_identifies_function_calls() {
        let function_call = ResponseItem::FunctionCall {
            id: Some("fc_123".to_string()),
            name: "read_file".to_string(),
            arguments: "{}".to_string(),
            call_id: "call_1".to_string(),
        };
        assert!(is_llm_generated(&function_call));

        let function_output = ResponseItem::FunctionCallOutput {
            call_id: "call_1".to_string(),
            output: FunctionCallOutputPayload {
                content: "output".to_string(),
                content_items: None,
                success: Some(true),
            },
        };
        assert!(!is_llm_generated(&function_output));
    }

    #[test]
    fn test_is_llm_generated_identifies_reasoning() {
        let reasoning = ResponseItem::Reasoning {
            id: "rs_123".to_string(),
            summary: vec![],
            content: None,
            encrypted_content: None,
        };
        assert!(is_llm_generated(&reasoning));
    }

    #[test]
    fn test_get_item_type_name_distinguishes_message_roles() {
        let assistant_msg = ResponseItem::Message {
            id: Some("msg_1".to_string()),
            role: "assistant".to_string(),
            content: vec![],
        };
        assert_eq!(get_item_type_name(&assistant_msg), "Message(assistant)");

        let user_msg = ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![],
        };
        assert_eq!(get_item_type_name(&user_msg), "Message(user)");

        let other_msg = ResponseItem::Message {
            id: None,
            role: "system".to_string(),
            content: vec![],
        };
        assert_eq!(get_item_type_name(&other_msg), "Message(other)");
    }

    #[test]
    fn test_get_item_type_name_for_function_call_with_name() {
        let function_call = ResponseItem::FunctionCall {
            id: Some("fc_1".to_string()),
            name: "read_file".to_string(),
            arguments: "{}".to_string(),
            call_id: "call_1".to_string(),
        };
        assert_eq!(
            get_item_type_name(&function_call),
            "FunctionCall(read_file)"
        );
    }

    #[test]
    fn test_get_item_type_name_for_function_output_success() {
        let function_output = ResponseItem::FunctionCallOutput {
            call_id: "call_1".to_string(),
            output: FunctionCallOutputPayload {
                content: "File content here".to_string(),
                content_items: None,
                success: Some(true),
            },
        };
        assert_eq!(
            get_item_type_name(&function_output),
            "FunctionCallOutput(Y, \"File content here\")"
        );
    }

    #[test]
    fn test_get_item_type_name_for_function_output_unknown_status() {
        let function_output = ResponseItem::FunctionCallOutput {
            call_id: "call_1".to_string(),
            output: FunctionCallOutputPayload {
                content: "output".to_string(),
                content_items: None,
                success: None,
            },
        };
        assert_eq!(
            get_item_type_name(&function_output),
            "FunctionCallOutput(?, \"output\")"
        );
    }

    #[test]
    fn test_get_item_type_name_for_custom_tool_call() {
        let custom_call = ResponseItem::CustomToolCall {
            id: Some("ct_1".to_string()),
            status: None,
            call_id: "call_1".to_string(),
            name: "mcp_search".to_string(),
            input: "{}".to_string(),
        };
        assert_eq!(
            get_item_type_name(&custom_call),
            "CustomToolCall(mcp_search)"
        );
    }

    #[test]
    fn test_get_item_type_name_for_custom_tool_output() {
        let custom_output = ResponseItem::CustomToolCallOutput {
            call_id: "call_1".to_string(),
            output: "Search result".to_string(),
        };
        assert_eq!(
            get_item_type_name(&custom_output),
            "CustomToolCallOutput(\"Search result\")"
        );
    }

    #[test]
    fn test_truncate_content_with_newlines() {
        let function_output = ResponseItem::FunctionCallOutput {
            call_id: "call_1".to_string(),
            output: FunctionCallOutputPayload {
                content: "line1\nline2\nline3".to_string(),
                content_items: None,
                success: Some(true),
            },
        };
        // Newlines should be replaced with spaces
        assert_eq!(
            get_item_type_name(&function_output),
            "FunctionCallOutput(Y, \"line1 line2 line3\")"
        );
    }

    #[test]
    fn test_get_item_type_names_returns_ordered_list() {
        let items = vec![
            ResponseItem::Message {
                id: None,
                role: "user".to_string(),
                content: vec![],
            },
            ResponseItem::Reasoning {
                id: "rs_1".to_string(),
                summary: vec![],
                content: None,
                encrypted_content: None,
            },
            ResponseItem::FunctionCall {
                id: Some("fc_1".to_string()),
                name: "tool".to_string(),
                arguments: "{}".to_string(),
                call_id: "call_1".to_string(),
            },
        ];

        let names = get_item_type_names(&items);
        assert_eq!(
            names,
            vec!["Message(user)", "Reasoning", "FunctionCall(tool)"]
        );
    }

    #[test]
    fn test_filter_incremental_input_returns_slice_after_last_llm() {
        let history = vec![
            ResponseItem::Message {
                id: None,
                role: "user".to_string(),
                content: vec![ContentItem::InputText {
                    text: "task".to_string(),
                }],
            },
            ResponseItem::Message {
                id: Some("msg_1".to_string()),
                role: "assistant".to_string(),
                content: vec![ContentItem::OutputText {
                    text: "thinking".to_string(),
                }],
            },
            ResponseItem::FunctionCall {
                id: Some("fc_1".to_string()),
                name: "tool".to_string(),
                arguments: "{}".to_string(),
                call_id: "call_1".to_string(),
            },
            ResponseItem::FunctionCallOutput {
                call_id: "call_1".to_string(),
                output: FunctionCallOutputPayload {
                    content: "result".to_string(),
                    content_items: None,
                    success: Some(true),
                },
            },
            ResponseItem::Message {
                id: None,
                role: "user".to_string(),
                content: vec![ContentItem::InputText {
                    text: "continue".to_string(),
                }],
            },
        ];

        let filtered = filter_incremental_input(&history);

        // Should return Some with items after FunctionCall (index 2)
        assert!(filtered.is_some());
        let filtered = filtered.unwrap();
        assert_eq!(filtered.len(), 2);
        assert!(matches!(
            filtered[0],
            ResponseItem::FunctionCallOutput { .. }
        ));
        assert!(matches!(
            filtered[1],
            ResponseItem::Message { ref role, .. } if role == "user"
        ));
    }

    #[test]
    fn test_filter_incremental_input_first_turn() {
        let history = vec![ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![ContentItem::InputText {
                text: "hello".to_string(),
            }],
        }];

        let filtered = filter_incremental_input(&history);

        // First turn: no LLM items, should return None
        assert!(filtered.is_none());
    }

    #[test]
    fn test_filter_incremental_input_llm_is_last() {
        let history = vec![ResponseItem::Message {
            id: Some("msg_1".to_string()),
            role: "assistant".to_string(),
            content: vec![],
        }];

        let filtered = filter_incremental_input(&history);

        // LLM item is last - should return Some(&[])
        assert!(filtered.is_some());
        assert_eq!(filtered.unwrap().len(), 0);
    }

    #[test]
    fn test_filter_incremental_input_handles_reasoning_as_llm() {
        let history = vec![
            ResponseItem::Reasoning {
                id: "rs_1".to_string(),
                summary: vec![],
                content: None,
                encrypted_content: None,
            },
            ResponseItem::FunctionCallOutput {
                call_id: "call_1".to_string(),
                output: FunctionCallOutputPayload {
                    content: "ok".to_string(),
                    content_items: None,
                    success: Some(true),
                },
            },
        ];

        let filtered = filter_incremental_input(&history);

        // Reasoning is LLM-generated, should return Some with only FunctionCallOutput
        assert!(filtered.is_some());
        let filtered = filtered.unwrap();
        assert_eq!(filtered.len(), 1);
        assert!(matches!(
            filtered[0],
            ResponseItem::FunctionCallOutput { .. }
        ));
    }

    #[test]
    fn test_filter_incremental_input_handles_compaction_summary() {
        let history = vec![
            ResponseItem::Message {
                id: Some("msg_1".to_string()),
                role: "assistant".to_string(),
                content: vec![],
            },
            ResponseItem::CompactionSummary {
                encrypted_content: "encrypted_summary".to_string(),
            },
        ];

        let filtered = filter_incremental_input(&history);

        // CompactionSummary is user input, should be included
        assert!(filtered.is_some());
        let filtered = filtered.unwrap();
        assert_eq!(filtered.len(), 1);
        assert!(matches!(
            filtered[0],
            ResponseItem::CompactionSummary { .. }
        ));
    }
}
