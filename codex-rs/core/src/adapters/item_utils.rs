//! Shared utilities for working with ResponseItems across adapters
//!
//! This module provides common functions for:
//! - Identifying LLM-generated vs user-input items
//! - Getting human-readable type names for debugging
//! - Supporting incremental input filtering logic

use codex_protocol::models::ResponseItem;

/// Determine if a ResponseItem was generated by the LLM.
pub fn is_llm_generated(item: &ResponseItem) -> bool {
    match item {
        // LLM outputs (server has via previous_response_id)
        ResponseItem::Message { role, .. } if role == "assistant" => true,
        ResponseItem::Reasoning { .. } => true,
        ResponseItem::FunctionCall { .. } => true,
        ResponseItem::CustomToolCall { .. } => true,
        ResponseItem::LocalShellCall { .. } => true,
        ResponseItem::WebSearchCall { .. } => true,

        // User inputs (server needs in request)
        ResponseItem::FunctionCallOutput { .. } => false,
        ResponseItem::CustomToolCallOutput { .. } => false,
        ResponseItem::Message { role, .. } if role == "user" => false,
        ResponseItem::GhostSnapshot { .. } => false,
        ResponseItem::CompactionSummary { .. } => false,
        ResponseItem::Other => false,

        // Edge case: message with unknown role (defensive)
        ResponseItem::Message { .. } => false,
    }
}

/// Get human-readable type name for a ResponseItem.
pub fn get_item_type_name(item: &ResponseItem) -> &'static str {
    match item {
        ResponseItem::Message { role, .. } if role == "assistant" => "Message(assistant)",
        ResponseItem::Message { role, .. } if role == "user" => "Message(user)",
        ResponseItem::Message { .. } => "Message(other)",
        ResponseItem::Reasoning { .. } => "Reasoning",
        ResponseItem::FunctionCall { .. } => "FunctionCall",
        ResponseItem::FunctionCallOutput { .. } => "FunctionCallOutput",
        ResponseItem::CustomToolCall { .. } => "CustomToolCall",
        ResponseItem::CustomToolCallOutput { .. } => "CustomToolCallOutput",
        ResponseItem::LocalShellCall { .. } => "LocalShellCall",
        ResponseItem::WebSearchCall { .. } => "WebSearchCall",
        ResponseItem::GhostSnapshot { .. } => "GhostSnapshot",
        ResponseItem::CompactionSummary { .. } => "CompactionSummary",
        ResponseItem::Other => "Other",
    }
}

/// Get type name breakdown for a slice of ResponseItems.
pub fn get_item_type_names(items: &[ResponseItem]) -> Vec<&'static str> {
    items.iter().map(get_item_type_name).collect()
}

/// Filter input to get items after last LLM-generated item (zero-copy).
///
/// Used for incremental mode when `previous_response_id` is present.
/// The server already has history up to the last LLM response, so we only
/// need to send user inputs that occurred after that point.
///
/// # Returns
///
/// - `None` - No LLM items found (first turn, caller should use full input)
/// - `Some(&[])` - LLM item is last (error state, caller should return error)
/// - `Some(&[...])` - Items after last LLM item (normal case)
///
/// # Example
///
/// ```
/// use codex_core::adapters::filter_incremental_input;
///
/// match filter_incremental_input(&prompt.input) {
///     None => /* first turn, use full input */,
///     Some(slice) if slice.is_empty() => /* error: no user input after LLM */,
///     Some(slice) => /* use filtered slice */,
/// }
/// ```
pub fn filter_incremental_input<'a>(full_input: &'a [ResponseItem]) -> Option<&'a [ResponseItem]> {
    let last_llm_idx = full_input.iter().rposition(is_llm_generated)?;
    Some(&full_input[last_llm_idx + 1..])
}

#[cfg(test)]
mod tests {
    use super::*;
    use codex_protocol::models::ContentItem;
    use codex_protocol::models::FunctionCallOutputPayload;

    #[test]
    fn test_is_llm_generated_identifies_assistant_messages() {
        let assistant_msg = ResponseItem::Message {
            id: Some("msg_123".to_string()),
            role: "assistant".to_string(),
            content: vec![ContentItem::OutputText {
                text: "response".to_string(),
            }],
        };
        assert!(is_llm_generated(&assistant_msg));

        let user_msg = ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![ContentItem::InputText {
                text: "query".to_string(),
            }],
        };
        assert!(!is_llm_generated(&user_msg));
    }

    #[test]
    fn test_is_llm_generated_identifies_function_calls() {
        let function_call = ResponseItem::FunctionCall {
            id: Some("fc_123".to_string()),
            name: "read_file".to_string(),
            arguments: "{}".to_string(),
            call_id: "call_1".to_string(),
        };
        assert!(is_llm_generated(&function_call));

        let function_output = ResponseItem::FunctionCallOutput {
            call_id: "call_1".to_string(),
            output: FunctionCallOutputPayload {
                content: "output".to_string(),
                content_items: None,
                success: Some(true),
            },
        };
        assert!(!is_llm_generated(&function_output));
    }

    #[test]
    fn test_is_llm_generated_identifies_reasoning() {
        let reasoning = ResponseItem::Reasoning {
            id: "rs_123".to_string(),
            summary: vec![],
            content: None,
            encrypted_content: None,
        };
        assert!(is_llm_generated(&reasoning));
    }

    #[test]
    fn test_get_item_type_name_distinguishes_message_roles() {
        let assistant_msg = ResponseItem::Message {
            id: Some("msg_1".to_string()),
            role: "assistant".to_string(),
            content: vec![],
        };
        assert_eq!(get_item_type_name(&assistant_msg), "Message(assistant)");

        let user_msg = ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![],
        };
        assert_eq!(get_item_type_name(&user_msg), "Message(user)");

        let other_msg = ResponseItem::Message {
            id: None,
            role: "system".to_string(),
            content: vec![],
        };
        assert_eq!(get_item_type_name(&other_msg), "Message(other)");
    }

    #[test]
    fn test_get_item_type_name_for_tool_items() {
        let function_call = ResponseItem::FunctionCall {
            id: Some("fc_1".to_string()),
            name: "read_file".to_string(),
            arguments: "{}".to_string(),
            call_id: "call_1".to_string(),
        };
        assert_eq!(get_item_type_name(&function_call), "FunctionCall");

        let function_output = ResponseItem::FunctionCallOutput {
            call_id: "call_1".to_string(),
            output: FunctionCallOutputPayload {
                content: "output".to_string(),
                content_items: None,
                success: Some(true),
            },
        };
        assert_eq!(get_item_type_name(&function_output), "FunctionCallOutput");
    }

    #[test]
    fn test_get_item_type_names_returns_ordered_list() {
        let items = vec![
            ResponseItem::Message {
                id: None,
                role: "user".to_string(),
                content: vec![],
            },
            ResponseItem::Reasoning {
                id: "rs_1".to_string(),
                summary: vec![],
                content: None,
                encrypted_content: None,
            },
            ResponseItem::FunctionCall {
                id: Some("fc_1".to_string()),
                name: "tool".to_string(),
                arguments: "{}".to_string(),
                call_id: "call_1".to_string(),
            },
        ];

        let names = get_item_type_names(&items);
        assert_eq!(names, vec!["Message(user)", "Reasoning", "FunctionCall"]);
    }

    #[test]
    fn test_filter_incremental_input_returns_slice_after_last_llm() {
        let history = vec![
            ResponseItem::Message {
                id: None,
                role: "user".to_string(),
                content: vec![ContentItem::InputText {
                    text: "task".to_string(),
                }],
            },
            ResponseItem::Message {
                id: Some("msg_1".to_string()),
                role: "assistant".to_string(),
                content: vec![ContentItem::OutputText {
                    text: "thinking".to_string(),
                }],
            },
            ResponseItem::FunctionCall {
                id: Some("fc_1".to_string()),
                name: "tool".to_string(),
                arguments: "{}".to_string(),
                call_id: "call_1".to_string(),
            },
            ResponseItem::FunctionCallOutput {
                call_id: "call_1".to_string(),
                output: FunctionCallOutputPayload {
                    content: "result".to_string(),
                    content_items: None,
                    success: Some(true),
                },
            },
            ResponseItem::Message {
                id: None,
                role: "user".to_string(),
                content: vec![ContentItem::InputText {
                    text: "continue".to_string(),
                }],
            },
        ];

        let filtered = filter_incremental_input(&history);

        // Should return Some with items after FunctionCall (index 2)
        assert!(filtered.is_some());
        let filtered = filtered.unwrap();
        assert_eq!(filtered.len(), 2);
        assert!(matches!(
            filtered[0],
            ResponseItem::FunctionCallOutput { .. }
        ));
        assert!(matches!(
            filtered[1],
            ResponseItem::Message { ref role, .. } if role == "user"
        ));
    }

    #[test]
    fn test_filter_incremental_input_first_turn() {
        let history = vec![ResponseItem::Message {
            id: None,
            role: "user".to_string(),
            content: vec![ContentItem::InputText {
                text: "hello".to_string(),
            }],
        }];

        let filtered = filter_incremental_input(&history);

        // First turn: no LLM items, should return None
        assert!(filtered.is_none());
    }

    #[test]
    fn test_filter_incremental_input_llm_is_last() {
        let history = vec![ResponseItem::Message {
            id: Some("msg_1".to_string()),
            role: "assistant".to_string(),
            content: vec![],
        }];

        let filtered = filter_incremental_input(&history);

        // LLM item is last - should return Some(&[])
        assert!(filtered.is_some());
        assert_eq!(filtered.unwrap().len(), 0);
    }

    #[test]
    fn test_filter_incremental_input_handles_reasoning_as_llm() {
        let history = vec![
            ResponseItem::Reasoning {
                id: "rs_1".to_string(),
                summary: vec![],
                content: None,
                encrypted_content: None,
            },
            ResponseItem::FunctionCallOutput {
                call_id: "call_1".to_string(),
                output: FunctionCallOutputPayload {
                    content: "ok".to_string(),
                    content_items: None,
                    success: Some(true),
                },
            },
        ];

        let filtered = filter_incremental_input(&history);

        // Reasoning is LLM-generated, should return Some with only FunctionCallOutput
        assert!(filtered.is_some());
        let filtered = filtered.unwrap();
        assert_eq!(filtered.len(), 1);
        assert!(matches!(
            filtered[0],
            ResponseItem::FunctionCallOutput { .. }
        ));
    }

    #[test]
    fn test_filter_incremental_input_handles_compaction_summary() {
        let history = vec![
            ResponseItem::Message {
                id: Some("msg_1".to_string()),
                role: "assistant".to_string(),
                content: vec![],
            },
            ResponseItem::CompactionSummary {
                encrypted_content: "encrypted_summary".to_string(),
            },
        ];

        let filtered = filter_incremental_input(&history);

        // CompactionSummary is user input, should be included
        assert!(filtered.is_some());
        let filtered = filtered.unwrap();
        assert_eq!(filtered.len(), 1);
        assert!(matches!(
            filtered[0],
            ResponseItem::CompactionSummary { .. }
        ));
    }
}
